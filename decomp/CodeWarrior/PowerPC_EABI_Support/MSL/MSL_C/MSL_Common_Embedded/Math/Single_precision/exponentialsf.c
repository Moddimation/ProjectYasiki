/*

  Author:  Matthew D. Fassiotto
  Date:    first written 4/15/99
  Purpose: portable single precision versions of ANSI standard powf(x,y),expf(x)
  functions and support functions.

  Notes:   log2f(x) is a supported part of C9X and is therefore supplied as
           a standard routine in a separate module(log2f.c).  This module is included
  as a header so that we can a. inline the code and avoid the overhead of a function
  call. b. turn off checks for special values(nans,infs, etc.. )since this is already
  performed ahead of time in pow.


  The single precision version of expf misses less than the last 3 bits when compared
  with the built in Intel algorithm(or a max of 5 ulps which occurs only 3 out of
  10,000,000 values tested). The result is the correctly rounded result produced from
  the Intel library over 67% of the time.  The accuracy can be further improved by
  writing the constants in two_to_frac as a vector and scaling the arithmetic in the
  reassembly step.

  Notes on expf powf:
     intends to fully comply w/C9X Annex


  error analysis:

    Most of the rounding errors are concentrated in the regions where expf^x
  approaches the upper limit of representable numbers(i.e. expf^^x ~= FLT_MAX,
  FLT_MIN).  In this case the variable transform from x to z=log2e*x is the principle
  cause.



  pow(x,y)=2^^(y*log2(x))
  -----------------------

  log2f returns the exact correctly rounded result(as is rounded from the correct
  IEEE double value to an IEEE float) > 99% of the time and misses at most the last
  bit. log2f is not a significant source of error.
  __2_to_x(float x) is basically the same routine as expf but eliminates the
  expensive variable transform step thereby leading to better performance.  __2_to_x
  is meant only for the powf function and is therefore not exported.

  Reducing fraction from [-.5,.5] to [0,.5] requires an unaligned add, 2 extra
  multiplies, and 2 other unaligned adds in the reassembly step.

  This can be eliminated by using a similarly accurate Chebyshev polynomial on
  [-.5,.5].  The unaligned adds and additional multiplies are the majority of the
  error in powf which can be eliminated once this new polynomial is calculated.

  powf currently differs from the correctly rounded double result by > 2 ulps  < 10%
  of the time.  However, near the upper limits of powf's range we incur significant
  error(for the same reason we see this in expf).  Again the Chebyshev polynomial on
  [-.5,.5] needs to be investigated as a means of eliminating this problem.


  Update Record
  --------------

  06/10/99 -- replaced original expf polynomial with a new Chebyshev polynomial
  converging on [-1,1] generated by Maple. old implementation is commented out at
  bottom of file.
*/

#include <cmath>

static const _INT32 _inf = 0x7f800000;
#define __INFINITY (*(float*)&_inf)

static const _INT32 _nan = 0x7fffffff;
#define __NAN (*(float*)&_nan)

#pragma cplusplus on
#define __LOG2_FOR_POWONLY 1 // prevents log2 from rechecking for bad values
#include <log2f.c>           // contains log2f as an inline

/* Maple 8th degree Chebyshev compaction polynomial for [-1,1] */

static const float __two_to_x[] = {
    .6931471767,    .2402265062,     .05550415684,   .009618134656, .001333182528,
    .0001540197657, .00001548327328, .1339281766e-5, .1029999862e-6
};
/*
static const float  __two_to_x[]={.6931471803f,.2402265069f,.05550410856f,
                                  .009618129100f,.001333356340f,.0001540353222f,
                                  .00001525152331,.1321502860e-5,.1029999862e-6,.1029999862e-6,
                                  .7111562337e-8};
 */
inline float
__2_to_x (float x)
{
    _INT32 int_part; // truncated x
    float  z;        // intermediate value evaluated by polynomial
    float  frac_part;
    // int_part= (signbit(x) )? (_INT32)(x-.5f) : (_INT32)(x+.5f);  //won't round to
    // even in half way cases(doesn't matter)
    int_part = (_INT32)x; // won't round to even in half way cases(doesn't matter)
    frac_part = x - (float)int_part; // this subtraction is exact

    if (int_part > 128)
    {
        return __INFINITY;
    }
    else if (int_part < -127)
    {
        return 0.0f;                 // flushes denormals to 0
    }
    else
    {
        int_part += 127;
        int_part <<= 23; // int_part is now an integral power of 2 in IEEE format
    }

    z = frac_part *
        (__two_to_x[0] +
         frac_part *
             (__two_to_x[1] +
              frac_part *
                  (__two_to_x[2] +
                   frac_part *
                       (__two_to_x[3] +
                        frac_part *
                            (__two_to_x[4] +
                             frac_part *
                                 (__two_to_x[5] +
                                  frac_part *
                                      (__two_to_x[6] +
                                       frac_part *
                                           (__two_to_x[7] +
                                            frac_part * __two_to_x[8]))))))));

                         // calculate 2^^x -1 -> z in [-.2928932,.4142135624]

    // reassemble

    return (*(float*)&int_part) * (.75f + (z + .25f));
}
extern "C" const float __two_to_log2e_m1_tI[];
extern "C" float
expf (float x)
{
    /* Maple 8th degree Chebyshev compaction polynomial for [-1,1] */

    static const float __exp_to_x[] = { .9999999009,    .4999999723,
                                        .1666679856,    .04166688600,
                                        .008328596116,  .001388275963,
                                        .0002046999276, .00002549918424 };
    if (x > 88.7228394f)
    {
        return __INFINITY;
    }
    if (x < -87.3365479f)
    {
        return 0.0f;
    }

    const _INT32 int_part = (_INT32)x;
    const float  frac_part = x - (float)int_part;
    _INT32       int_index = int_part + 88;
    float        power_of_two, z = 0.0f;
    *(_UINT32*)&power_of_two = (int_index) + 39 << 23; // 127-88=39;

#if __INTEL__ && __option(k63d)
    const _INT32 table_address = 4 * int_index;
    asm
        {   
     mov eax, table_address
     prefetch __two_to_log2e_m1_tI[eax]
        }
#endif

    z = frac_part *
        (__exp_to_x[0] +
         frac_part *
             (__exp_to_x[1] +
              frac_part *
                  (__exp_to_x[2] +
                   frac_part *
                       (__exp_to_x[3] +
                        frac_part *
                            (__exp_to_x[4] +
                             frac_part *
                                 (__exp_to_x[5] +
                                  frac_part * (__exp_to_x[6] +
                                               frac_part * __exp_to_x[7])))))));

    // the above poly is (e^frac_part) - 1
    // Note: due to the non-transitive nature of floating point arithmetic, the above
    // poly would be much less accurate if vectorization is attempted(e.g.
    // accumulating odd and even terms then accumulating). The order of operations
    // above must be maintained to acheive this level of accuracy.

    // note: z is in ~[(e^-1)-1,(e^1)-1]=[-.6321205588,1.718281828]
    //  reassemble
    // z=__two_to_log2e_m1_tI[int_index]*(power_of_two*(.75f + (.25f+ z)));
    return __two_to_log2e_m1_tI[int_index] *
           (power_of_two * (.9921875f + (.007812501f + z)));
}
extern "C" float
powf (float x, float y)
{
    int tmp;
    if (x > 0.0f)
    {
#if __DSP
        return exp (y * logf (x));
#else
        return __2_to_x (y * __log2f (x));
#endif
    }
    else if (x < 0.0f)                       // bug: bad for -0
    {
        tmp = y;
        if ((y - (float)tmp))
        {
            return __NAN;                    /* true for non-integral exponents */
        }
        else
        {
#if __DSP
            if (tmp % 2)
            {
                return -exp (y * logf (-x)); /* odd integral exponent */
            }

            return exp (y * logf (-x));      /* even integral exponent */
#else
            if (tmp % 2)
            {
                return -__2_to_x (y * __log2f (-x)); /* odd integral exponent */
            }

            return __2_to_x (y * __log2f (-x));      /* even integral exponent */
#endif
        }
    }

    /* x=0.0f or perhaps a __NAN */
    if (isnan (x))
    {
        return x;
    }

    /* x is 0.0 if we reach the switch */

    switch (fpclassify (y))
    {
        case FP_ZERO:
            return 1.0f;
            break;
        case FP_NAN:
        case FP_INFINITE:
            return __NAN;
            break;
        case FP_NORMAL:
        case FP_SUBNORMAL:
            if (y < 0.0f)
            {
                if (x == -0.0f)
                {
                    return -__INFINITY;
                }
                else // then x == +0.0f
                {
                    return __INFINITY;
                }
            }
            break;
    }
    return 0.0f;
}
#pragma cplusplus reset
/*



 static const float scale_frac[]={0.0f,.5f};
 static const int log2e_bits[]={0x3FA80000,0x3E051180,0x3980b215,0x3180c17f};
 static const float two_to_frac[]={1.0f, 0.7071067811865f};
 static const float
log2e[]={*(float*)&log2e_bits[0],*(float*)&log2e_bits[1],*(float*)&log2e_bits[2],*(float*)&log2e_bits[3]};
//polynomial 1023 pg.169 Hart et. al.
/* static const float  __two_to_x[]={.693147177596419,.240226604484390,

 static const float  __two_to_x[]={.69314717759,.240226604484390,.05550291569,
                                   .009625022610,.001313105385,.0001830080601};
 static const float two_to_frac_hi[]={1.0f,0.7071065};
 static const float two_to_frac_lo[]={0.0f,.0000002812f,};
 static const float scale_frac[]={0.0f,.5f};
 static const float two_to_frac[]={1.0,.7071067812};
 static int log2e_bits[]={0x3FA80000,0x3E051180,0x3980b215,0x3180c17f};
 static double
log2e[]={(double)*(float*)&log2e_bits[0],(double)*(float*)&log2e_bits[1],
                        (double)*(float*)&log2e_bits[2],(double)*(float*)&log2e_bits[3]};


inline float expf(float x)
 {
  _INT32 int_part;
  _INT32 index=0;
  float z;
  const int int_x=x;
  const float frac_x=x-int_x;
  float frac_part;
  z=x*log2e[0] + (x*log2e[1] + (x*log2e[2] + x*log2e[3]));   // extra bits for
log2(e) forces correct rounding

  int_part= (signbit(z) )? (_INT32)(z-.5f) : (_INT32)(z+.5f);  //won't round to even
in half way cases(doesn't matter) frac_part=(int_x*log2e[0] - (float)int_part) +
(int_x*log2e[1] + (frac_x*log2e[0] + ( int_x*log2e[2] + (frac_x*log2e[1]
+(frac_x*log2e[2] + x*log2e[3])))));
//temp=x*y -(float)int_part;

  int_part+=127;
  int_part<<=23;               // int_part is now an integral power of 2 in IEEE
format if(frac_part < 0.0f) index+=1;                  // arrays are setup so that
negative fractions start 4 from beginning
                               // of array(right after positive scale values)

 z=frac_part+scale_frac[index];  //puts z in [0,.25]



 z= z*( __two_to_x[0] + z*( __two_to_x[1] + z*( __two_to_x[2] +
    z*( __two_to_x[3] + z*( __two_to_x[4] + z*__two_to_x[5]) ))));

  // reassemble
#if __MIPS__
  z=__int2float__(int_part)*((two_to_frac_hi[index] + two_to_frac_hi[index]*z) +
                          (two_to_frac_lo[index]*z + two_to_frac_lo[index]));
#else
 z=(*(float*)&int_part)*(two_to_frac_hi[index] + (two_to_frac_lo[index]+
   (two_to_frac_lo[index]*z + two_to_frac_hi[index]*z)));

#endif

  return z;

}
*/
/*
extern "C" float expf(float x)
 {
  _INT32 int_part;
  _INT32 index=0;
  float z;
  const int int_x=x;                                          // truncated x
  const float frac_x=x-int_x;
  float frac_part;

  z=x* log2e[0] + (x*log2e[1] + (x*log2e[2] + x*log2e[3]));    // extra bits for
log2(e) forces correct rounding

  int_part= (signbit(z) )? (_INT32)(z-.5f) : (_INT32)(z+.5f); // won't round to even
in half way cases(doesn't matter)

 //the order and number of terms below has an affect on accuracy.  This should not be
changed.

  frac_part=(int_x*log2e[0] - (float)int_part) + (int_x*log2e[1] + (frac_x*log2e[0] +
( int_x*log2e[2] + (frac_x*log2e[1] +(frac_x*log2e[2] + x*log2e[3])))));

  int_part+=127;
  int_part<<=23;               // int_part is now an integral power of 2 in IEEE
format if(int_part < 0) return __INFINITY;           // too big if(frac_part < 0.0f)
    index+=1;                  // arrays are setup so that negative fractions start 4
from beginning
                               // of array(right after positive scale values)

  z=frac_part+scale_frac[index];  //puts z in [0,.5]
  z= z*( __two_to_x[0] + z*( __two_to_x[1] + z*( __two_to_x[2] +
     z*( __two_to_x[3] + z*( __two_to_x[4] + z*__two_to_x[5]) ))));

  // reassemble
#if __MIPS__
   return __int2float__(int_part)*(two_to_frac[index] + two_to_frac[index]*z);
#else
  return (*(float*)&int_part)*(.75f*two_to_frac[index] + two_to_frac[index]*(z+
.25f)); #endif

}
*/
